(load "structures.pot")

;;; errors
(define make-error
  (func (str)
    (error str)))

;;; namespaces
;;; represented as (<parent>, <dictionary>) where dictionary assigns symbols to values

(define make-namespace
  (func ()
    (cons nil (make-small-dict))))

(define make-namespace-with-parent
  (func (parent)
    (cons parent (make-small-dict))))

(define get-namespace-parent
  (func (nspace)
    (first nspace)))

(define get-namespace-dict
  (func (nspace)
    (rest nspace)))

(define lookup
  (func (nspace symbol)
    (let ((looked-up . (dict-get (get-namespace-dict nspace) symbol)))
	 (if looked-up
	     (cons 't looked-up)
	     (if (dict-has (get-namespace-dict nspace) symbol) ; looked up nil
		 (cons 't nil)
		 (if (get-namespace-parent nspace)
		     (lookup (get-namespace-parent nspace) symbol)
		     (make-error (snprintf "symbol '%s' unbound" 100 symbol))))))))

(define soft-bind
  (func (nspace symbol value)
    (if (dict-get (get-namespace-dict nspace) symbol)
	(make-error (snprintf "symbol '%s' already bound" 100 symbol))
	(dict-put (get-namespace-dict nspace) symbol value))))

(define hard-bind
  (func (nspace symbol value)
    (dict-put (get-namespace-dict nspace) symbol value)))

(define list-bindings
  (func (nspace)
    (define erase-last-nil
      (func (dict-list)
	(if (first dict-list)
	    (cons (first dict-list) (erase-last-nil (rest dict-list)))
	    nil)))
    (erase-last-nil (dict-entries (get-namespace-dict nspace)))))

;;; evaluation

(define apply-operator
  (func (operator operands namespace)
    (if (= (type operator) 'FUNCTION) ; i.e. black box
	(operator operands namespace)
	(format "cannot apply non-function to operands" sys-stdout))))
	;; (if (= (type operator) 'CELL) ; defined at bootstrapped level
	;;     (apply-proc operator operands namespace)
	;;     (format "cannot apply non-callable to operands" sys-stdout)))))

(define evaluate-under-namespace
  (func (nspace expr)
    (if (= (type expr) 'CELL)
	(apply-operator (evaluate-under-namespace nspace (first expr))
			(rest expr) nspace)
	(if (= (type expr) 'SYMBOL)
	    (let ((looked-up . (lookup nspace expr)))
		 (if (= (type looked-up) 'ERROR)
		     looked-up
		     (rest looked-up))) ; remove the 't in front
	    expr))))

;;; defaults

;; calls the first argument under _this_ namespace
(define direct-call-operator
  (func (operands namespace)
    (eval (first operands))))

;; returns bindings in this namespace
(define show-current-name-bindings-operator
  (func (operands namespace)
    (if operands
	(format "argument help lookup not yet supported" sys-stdout)
	(list-bindings namespace))))

(define populate-default-namespace
  (func (nspace)
    (hard-bind nspace '_ direct-call-operator)
    (hard-bind nspace '? show-current-name-bindings-operator)
    nspace))

;; return an interpreter's evaluate function
(define make-interpreter
  (func ()
    (define global-namespace (populate-default-namespace (make-namespace)))
    (define top-level-evaluate
      (func (expr)
	(let ((result . (evaluate-under-namespace global-namespace expr)))
	     (if (= (type result) 'ERROR)
		 (print result)
		 result))))
    top-level-evaluate))
