(load "structures.pot")

;;; errors
(define make-error
  (func (str)
    (error str)))

;;; namespaces
;;; represented as (<parent>, <dictionary>) where dictionary assigns symbols to values

(define make-namespace
  (func ()
    (cons nil (make-small-dict))))

(define make-namespace-with-parent
  (func (parent)
    (cons parent (make-small-dict))))

(define get-namespace-parent
  (func (nspace)
    (first nspace)))

(define get-namespace-dict
  (func (nspace)
    (rest nspace)))

(define lookup
  (func (nspace symbol)
    (let ((looked-up . (dict-get (get-namespace-dict nspace) symbol)))
	 (if looked-up
	     (cons 't looked-up)
	     (if (dict-has (get-namespace-dict nspace) symbol) ; looked up nil
		 (cons 't nil)
		 (if (get-namespace-parent nspace)
		     (lookup (get-namespace-parent nspace) symbol)
		     (make-error (snprintf "POTATO: symbol '%s' unbound" 100 symbol))))))))

(define soft-bind
  (func (nspace symbol value)
    (if (dict-get (get-namespace-dict nspace) symbol)
	(make-error (snprintf "POTATO: symbol '%s' already bound" 100 symbol))
	(dict-put (get-namespace-dict nspace) symbol value))))

(define hard-bind
  (func (nspace symbol value)
    (dict-put (get-namespace-dict nspace) symbol value)))

(define list-bindings
  (func (nspace)
    (define erase-last-nil
      (func (dict-list)
	(if (first dict-list)
	    (cons (first dict-list) (erase-last-nil (rest dict-list)))
	    nil)))
    (erase-last-nil (dict-entries (get-namespace-dict nspace)))))

;;; subroutines, callables, etc.

;; just a block of expressions to be evaluated under scope of _lexical_ parent
;; <operands> is a list of expressions
;; returns result of last expression
;; NOTE: passed arguments and environment at call do NOT affect execution of a
;; subroutine
(define make-subroutine
  (func (operands namespace)
    (define call
      (func (args call-namespace) ; TODO not properly tail-recursive
	(last (map (func (expr) (evaluate-under-namespace namespace expr))
	     operands))))
    call))

;; called by make-function and make-macro
;; originally part of make-function: abstracted out so that make-macro can
;; choose not to pre-evaluate arguments
(define procedure-factory
  (func (pre-evaluate? operands decl-namespace)

    (define check-arglen
      (func (args param-count)
	(define arg-count (length args))
	(or (= param-count arg-count) (= (* -1 param-count) arg-count))))

    (define init-function-frame
      (func (params args function-frame call-namespace)
	(if params
	    (if (= (type params) 'SYMBOL)
		(soft-bind function-frame params args)
		(let ()
		     (soft-bind function-frame (first params)
				(if pre-evaluate?
				    (evaluate-under-namespace call-namespace (first args))
				    (first args)))
		     (init-function-frame (rest params) (rest args) function-frame call-namespace)))
	    nil)))

    (define call
      (func (args call-namespace)
	(define params (first operands))
	(define body (rest operands))
	(define num-params (length params))
	(define function-frame (make-namespace-with-parent decl-namespace))

	(if (check-arglen args num-params)
	    (let ()
		 (init-function-frame params args function-frame call-namespace)
		 ((make-subroutine body function-frame) 0 0)) ; pass 0 because args don't matter
	    (make-error (snprintf "POTATO: function called with %d arguments but created with %d parameters" 100 (length args) num-params)))))

    (if (not (> (length operands) 0))
	(make-error "POTATO: must provide argument list to create function")
	call)))

;; declare a variable-length parameter list function with lexical scoping
;; first of <operands> is argument list e.g. (x y . z)
;; rest of <operands> is function body
(define make-function
  (func (operands namespace)
    (procedure-factory 'yes operands namespace)))

;; make-function, without prior evaluation of arguments and with
;; evaluation of generated code
(define make-macro
  (func (operands namespace)
    (define code-generator (procedure-factory nil operands namespace))
    (define call
      (func (args call-namespace)
	(evaluate-under-namespace call-namespace (code-generator args call-namespace))))
    call))

;;; evaluation

(define apply-operator
  (func (operator operands namespace)
    (if (= (type operator) 'FUNCTION) ; i.e. black box
	(operator operands namespace)
	(format "cannot apply non-function to operands" sys-stdout))))
	;; (if (= (type operator) 'CELL) ; defined at bootstrapped level
	;;     (apply-proc operator operands namespace)
	;;     (format "cannot apply non-callable to operands" sys-stdout)))))

(define evaluate-under-namespace
  (func (nspace expr)
    (if (= (type expr) 'CELL)
	(apply-operator (evaluate-under-namespace nspace (first expr))
			(rest expr) nspace)
	(if (= (type expr) 'SYMBOL)
	    (let ((looked-up . (lookup nspace expr)))
		 (if (= (type looked-up) 'ERROR)
		     looked-up
		     (rest looked-up))) ; remove the 't in front
	    expr))))

;;; defaults

;; calls the first argument under _this_ namespace
;; essentially leaks calls to this eval (implemented in C)
(define direct-call-operator
  (func (operands namespace)
    (eval (first operands))))

;; returns bindings in this namespace
(define show-current-name-bindings-operator
  (func (operands namespace)
    (if operands
	(format "argument help lookup not yet supported" sys-stdout)
	(list-bindings namespace))))

(define populate-default-namespace
  (func (nspace)
    (hard-bind nspace '_ direct-call-operator)
    (hard-bind nspace '? show-current-name-bindings-operator)
    (hard-bind nspace 'subroutine make-subroutine)
    (hard-bind nspace 'func make-function)
    (hard-bind nspace 'function make-function)
    (hard-bind nspace 'macro make-macro)
    nspace))

;; return an interpreter's evaluate function
(define make-interpreter
  (func ()
    (define global-namespace (populate-default-namespace (make-namespace)))
    (define top-level-evaluate
      (func (expr)
	(let ((result . (evaluate-under-namespace global-namespace expr)))
	     (if (= (type result) 'ERROR)
		 (print result)
		 result))))
    top-level-evaluate))
