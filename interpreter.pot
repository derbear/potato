(load "structures.pot")

;;; errors
(define make-error
  (func (str)
    (error str)))

;;; callframes
;;; represented as (<parent>, <dictionary>) where dictionary assigns symbols to values

(define make-callframe
  (func ()
    (cons nil (make-small-dict))))

(define empty-callframe (make-callframe)) ; constant

(define make-callframe-with-parent
  (func (parent)
    (cons parent (make-small-dict))))

(define get-callframe-parent
  (func (frame)
    (first frame)))

(define get-callframe-dict
  (func (frame)
    (rest frame)))

(define lookup
  (func (frame symbol)
    (let ((looked-up . (dict-get (get-callframe-dict frame) symbol)))
	 (if looked-up
	     (cons 't looked-up)
	     (if (dict-has (get-callframe-dict frame) symbol) ; looked up nil
		 (cons 't nil)
		 (if (get-callframe-parent frame)
		     (lookup (get-callframe-parent frame) symbol)
		     (make-error (snprintf "POTATO: symbol '%s' unbound" 100 symbol))))))))

(define soft-bind
  (func (frame symbol value)
    (if (dict-get (get-callframe-dict frame) symbol)
	(make-error (snprintf "POTATO: symbol '%s' already bound" 100 symbol))
	(dict-put (get-callframe-dict frame) symbol value))))

(define hard-bind
  (func (frame symbol value)
    (dict-put (get-callframe-dict frame) symbol value)))

(define list-bindings
  (func (frame)
    (define erase-last-nil
      (func (dict-list)
	(if (first dict-list)
	    (cons (first dict-list) (erase-last-nil (rest dict-list)))
	    nil)))
    (erase-last-nil (dict-entries (get-callframe-dict frame)))))

;;; subroutines, callables, etc.

;; just a block of expressions to be evaluated under scope of _lexical_ parent
;; <operands> is a list of expressions
;; returns result of last expression
;; NOTE: passed arguments and environment at call do NOT affect execution of a
;; subroutine
(define make-subroutine
  (func (operands callframe)
    (define call
      (func (args call-callframe) ; TODO not properly tail-recursive
	(last (map (func (expr) (evaluate-under-callframe callframe expr))
	     operands))))
    call))

;; called by make-function and make-macro
;; originally part of make-function: abstracted out so that make-macro can
;; choose not to pre-evaluate arguments
(define procedure-factory
  (func (pre-evaluate? operands decl-callframe)

    (define check-arglen
      (func (args param-count)
	(define arg-count (length args))
	(or (= param-count arg-count)
	    (<= (- (* -1 param-count) 1) arg-count))))

    (define init-function-frame
      (func (params args function-frame call-callframe)
	(if params
	    (if (= (type params) 'SYMBOL)
		(if pre-evaluate?
		    (soft-bind function-frame params (map
						      (func (x) (evaluate-under-callframe call-callframe x))
						      args))
		    (soft-bind function-frame params args))
		(let ()
		     (soft-bind function-frame (first params)
				(if pre-evaluate?
				    (evaluate-under-callframe call-callframe (first args))
				    (first args)))
		     (init-function-frame (rest params) (rest args) function-frame call-callframe)))
	    nil)))

    (define call
      (func (args call-callframe)
	(define params (first operands))
	(define body (rest operands))
	(define num-params (length params))
	(define function-frame (make-callframe-with-parent decl-callframe))

	(if (check-arglen args num-params)
	    (let ()
		 (init-function-frame params args function-frame call-callframe)
		 ((make-subroutine body function-frame) 0 0)) ; pass 0 because args don't matter
	    (make-error (snprintf "POTATO: function called with %d arguments but created with %d parameters" 100 (length args) num-params)))))

    (if (not (> (length operands) 0))
	(make-error "POTATO: must provide argument list to create function")
	call)))

;; declare a variable-length parameter list function with lexical scoping
;; first of <args+body> is argument list e.g. (x y . z)
;; rest of <args+body> is function body
(define make-function
  (func (args+body declared-callframe)
    (procedure-factory 'yes args+body declared-callframe)))

;; make-function, without prior evaluation of arguments and with
;; evaluation of generated code
(define make-macro
  (func (operands callframe)
    (define code-generator (procedure-factory nil operands callframe))
    (define call
      (func (args call-callframe)
	(evaluate-under-callframe call-callframe (code-generator args call-callframe))))
    call))

;;; evaluation

(define apply-operator
  (func (operator operands callframe)
    (if (= (type operator) 'FUNCTION)
	(operator operands callframe)
	(format "cannot apply non-function to operands" sys-stdout))))

(define evaluate-under-callframe
  (func (frame expr)
    (if (= (type expr) 'CELL)
	(apply-operator (evaluate-under-callframe frame (first expr))
			(rest expr) frame)
	(if (= (type expr) 'SYMBOL)
	    (let ((looked-up . (lookup frame expr)))
		 (if (= (type looked-up) 'ERROR)
		     looked-up
		     (rest looked-up))) ; remove the 't in front
	    expr))))

;;; defaults

;; calls the first argument under _this_ namespace
;; essentially leaks calls to this eval (implemented in C)
(define direct-call-operator
  (func (operands namespace)
    (eval (first operands))))

;; returns bindings in this callframe
(define show-current-name-bindings-operator
  (func (operands callframe)
    (if operands
	(format "argument help lookup not yet supported" sys-stdout)
	(list-bindings namespace))))

(define populate-default-namespace
  (func (nspace)
    (hard-bind nspace '_ direct-call-operator)
    (hard-bind nspace '? show-current-name-bindings-operator)
    (hard-bind nspace 'subroutine make-subroutine)
    (hard-bind nspace 'func make-function)
    (hard-bind nspace 'function make-function)
    (hard-bind nspace 'macro make-macro)
    nspace))

;; return an interpreter's evaluate function
(define make-interpreter
  (func ()
    (define global-callframe (populate-default-callframe (make-callframe)))
    (define top-level-evaluate
      (func (expr)
	(let ((result . (evaluate-under-callframe global-callframe expr)))
	     (if (= (type result) 'ERROR)
		 (print result)
		 result))))
    top-level-evaluate))
