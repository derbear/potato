(load "bind-native.pot")

;;; List utils

;; return -1 * number of cells if not nil-terminated e.g. (1 2 3 . 4) returns -4
;; return nil if malformed
(define length
  (func (list)
    (define length-helper
      (func (remaining count)
	(if remaining
	    (if (= (type remaining) 'CELL)
		(length-helper (rest remaining) (+ 1 count))
		(* -1 (+ 1 count)))
	    count)))
    (length-helper list 0)))

(define last
  (func (list)
    (if list
	(if (rest list)
	    (last (rest list))
	    (first list))
	list))) ; nil

(define second
  (func (list)
    (if list
	(if (rest list)
	    (first (rest list))
	    (make-error "cannot get second of length-1 list"))
	(make-error "cannot get second of length-0 list"))))

(define append
  (func (l1 l2)
    (if l1
	(cons (first l1) (append (rest l1) l2))
	l2)))

(define map
  (func (f list)
    (if list
	(cons (f (first list)) (map f (rest list)))
	list))) ; nil

;;; Logic and comparators

(define not
  (func (pred)
    (if pred
	nil
	'true)))

(define andf
  (func (p1 p2)
    (list 'if p1
	  (list 'if p2 ''t nil)
	  nil)))
(define and (macro andf))

(define orf
  (func (p1 p2)
    (list 'if p1
	  ''t
	  (list 'if p2 ''t nil))))
(define or (macro orf))

(define >
  (func (a b)
    (< b a)))

(define <=
  (func (a b)
    (or (< a b) (= a b))))

(define >=
  (func (a b)
    (or (> a b) (= a b))))

;; (cond (<cond1> <expr1>)
;;       (<cond2> <expr2>)
;;       ...
;;       (<condn> <exprn>)
;;       (else <expr'>))
;; if else clause is missing, then implicit (else nil)
;; generates equivalent chained if-expression
(define condf
  (func switch-list
    (define cook-cond-statement
      (func (conditional consequence alternative)
	(list 'if conditional consequence alternative)))
    (define condf-helper
      (func (switch-list)
	(if (rest switch-list)
	    (cook-cond-statement (first (first switch-list))
				 (second (first switch-list))
				 (condf-helper (rest switch-list)))
	    (if (= (first (first switch-list)) 'else) ; (cond (else <expr>))
		(second (first switch-list))
		nil))))
    (condf-helper switch-list)))

(define cond (macro condf))

;;; Control flow

;; evaluate expressions under once-evaluated local name-bindings
;; args should look like (<bindings> <expr1> <expr2> ...)
;; bindings looks something like ((a . 3) (b . 5))
;; cannot do dependent bindings like ((a . 3) (b . (+ a 2)))
;;;;;
;;    Generates:
;;    ((func param-list expressions) value-list)))
;;;;;
(define letf
  (func args
    (define bindings (first args))
    (define param-list (map first bindings))
    (define value-list (map (func (pair) (rest pair)) bindings))
    (define expressions (rest args))
    (cons (cons 'func (cons param-list expressions)) value-list)))

(define let (macro letf))

;;; I/O

(define format
  (func (str dest)
    (define vector (vector-from-string str))
    (define vector-len (vector-length vector))
    (define print-char-at
      ;; prints character at index
      (func (vector index)
	(c-putc dest (vector-index vector index))))
    (define format-recur
      (func (vector index)
	(if (>= index vector-len)
	    str
	    ((func ()
	       (print-char-at vector index)
	       (format-recur vector (+ index 1)))))))
    (format-recur vector 0)))

;;; Main code

(load "interpreter.pot")

(define bootstrap-eval (make-interpreter))

;; (define repl-closure
(define repl
  (func (prompt)
    (format prompt sys-stdout)
    (print (bootstrap-eval (read)))
;    (print (eval (read)))
    (repl prompt)))

(if (= 1 (length program-arguments))
    (repl "> ")
    (load (first (rest program-arguments))))
