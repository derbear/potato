;;; List utils

(define length
  (func (list)
    (if list
	(+ 1 (length (rest list)))
	0)))

(define append
  (func (l1 l2)
    (if l1
	(cons (first l1) (append (rest l1) l2))
	l2)))

(define map
  (func (f list)
    (if list
	(cons (f (first list)) (map f (rest list)))
	list))) ; nil

;;; Logic and comparators

(define not
  (func (pred)
    (if pred
	nil
	'true)))

(define andf
  (func (p1 p2)
    (list 'if p1
	  (list 'if p2 ''t nil)
	  nil)))
(define and (macro andf))

(define orf
  (func (p1 p2)
    (list 'if p1
	  ''t
	  (list 'if p2 ''t nil))))
(define or (macro orf))

(define >
  (func (a b)
    (< b a)))

(define <=
  (func (a b)
    (or (< a b) (= a b))))

(define >=
  (func (a b)
    (or (> a b) (= a b))))

;;; Control flow

;; evaluate a block of expressions and return the value of the last one
(define do-block
  (func expressions
    (if expressions
	(if (rest expressions)
	    ((func ()
	       (eval (first expressions))
	       (apply do-block (rest expressions))))
	    (eval (first expressions)))
	nil))) ; return nil

;; evaluate expressions under once-evaluated local name-bindings
;; args should look like (<bindings> <expr1> <expr2> ...)
;; bindings looks something like ((a . 3) (b . 5))
;; cannot do dependent bindings like ((a . 3) (b . (+ a 2)))
;;;;;
;;    Generates:
;;    ((func param-list expressions) value-list)))
;;;;;
(define letf
  (func args
    (define bindings (first args))
    (define param-list (map first bindings))
    (define value-list (map (func (pair) (rest pair)) bindings))
    (define expressions (rest args))
    (cons (cons 'func (cons param-list expressions)) value-list)))

(define let (macro letf))

;;; I/O

(define format
  (func (str dest)
    (define vector (vector-from-string str))
    (define vector-len (vector-length vector))
    (define print-char-at
      ;; prints character at index
      (func (vector index)
	(c-putc dest (vector-index vector index))))
    (define format-recur
      (func (vector index)
	(if (>= index vector-len)
	    str
	    ((func ()
	       (print-char-at vector index)
	       (format-recur vector (+ index 1)))))))
    (format-recur vector 0)))

;;; Main code

(load "interpreter.pot")

(define bootstrap-eval (make-interpreter))

;; (define repl-closure
(define repl
  (func (prompt)
    (format prompt sys-stdout)
    (print (bootstrap-eval (read)))
    (repl prompt)))

(if (= 1 (length program-arguments))
    (repl "> ")
    (load (first (rest program-arguments))))
