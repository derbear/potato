;;; List utils

(define length
  (func (list)
    (if list
	(+ 1 (length (rest list)))
	0)))

(define append
  (func (l1 l2)
    (if l1
	(cons (first l1) (append (rest l1) l2))
	l2)))

(define map
  (func (f list)
    (if list
	(cons (f (first list)) (map f (rest list)))
	list))) ; nil

(define list-copy!
  (func (source-list dest-list)
    (if (rest source-list)
	((func ()
	   (set-first dest-list (first source-list))
	   (list-copy! (rest source-list) (rest dest-list))))
	((func ()
	   (set-first dest-list (first source-list))
	   (set-rest dest-list (rest source-list)))))))

;;; Logic and comparators

(define not
  (func (pred)
    (if pred
	nil
	'true)))

(define andf
  (func (p1 p2)
    (list 'if p1
	  (list 'if p2 ''t nil)
	  nil)))
(define and (macro andf))

(define orf
  (func (p1 p2)
    (list 'if p1
	  ''t
	  (list 'if p2 ''t nil))))
(define or (macro orf))

(define >
  (func (a b)
    (< b a)))

(define <=
  (func (a b)
    (or (< a b) (= a b))))

(define >=
  (func (a b)
    (or (> a b) (= a b))))

;;; I/O

(define format
  (func (str dest)
    (define vector (vector-from-string str))
    (define vector-len (vector-length vector))
    (define print-char-at
      ;; prints character at index
      (func (vector index)
	(c-putc dest (vector-index vector index))))
    (define format-recur
      (func (vector index)
	(if (>= index vector-len)
	    str
	    ((func ()
	       (print-char-at vector index)
	       (format-recur vector (+ index 1)))))))
    (format-recur vector 0)))

;;; Main code

(load "interpreter.pot")

(define global-interpreter-evaluate (make-interpreter))

;; (define repl-closure
(define repl
  (func ()
    ;; (format "> " sys-stdout)
    (print (eval (read)))
    (repl)))

(if (= 1 (length program-arguments))
    (repl)
    (load (first (rest program-arguments))))
